<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="rc10r1frametest-%E8%AF%B4%E6%98%8E%E4%B9%A6">RC10_R1_FRAME_TEST 说明书</h2>
<h3 id="%E7%AE%80%E4%BB%8B">简介</h3>
<pre><code>此文档重在记录RC10_LIB的设计思路，若是想快速上手RC10_LIB还请移步用户手册。
此文档写的还是相对凌乱，大多时候只是用来记录笔者的想法和实现
</code></pre>
<h3 id="%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">编码方式</h3>
<pre><code>统一使用GB2312
</code></pre>
<h3 id="%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">命名规范</h3>
<pre><code>在类中的变量统一带_的后缀，形参不带后缀
</code></pre>
<h3 id="%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84">文件架构</h3>
<ol>
<li>BSP_Driver
此用于存放最底层驱动，如fdCAN, UASRT, SPI IIC, TIM RTOS等驱动。
前缀为==BSP_==</li>
<li>Motor
此用于存放电机驱动.
前缀为==Motor==</li>
<li>APP
此用于存放控制器、滤波器和一些工具，又亦或是其他复用性强的算法之类的。
前缀为==APP==</li>
<li>Module
此用于一些复用性强的模块的封装，如激光测距模块、灯带等等
此前缀为==Module==</li>
</ol>
<h5 id="%E7%9B%AE%E5%89%8D%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF">目前的设计思路</h5>
<p>用统一的FdCanBus 封装负责fdCAN硬件、过滤与RX分发。用Motor基类定义统一接口，而motor基类可以派生两个主要子类：<code>DJIMotor</code>和<code>ExtendedMotor</code>。这是由于两种电机的报文发送机制不同。使用FreeRTOS(队列\任务)将CAN的收发与电机控制解耦，使用ID映射或查表方式将接收报文分发到正确的电机对象。</p>
<ol>
<li>
<p>fdCanBus设计需求
作为通信通道，而不是直接服务电机（与RC9的不同点）</p>
<ol>
<li>单路CAN能够混搭标准帧和拓展帧</li>
<li>使用FIFO接收CAN帧，ISR简化，只搬运报文，不解析，解析放到RTOS任务中进行</li>
<li>fdCanBus创建对象后自动生成对应任务</li>
<li>封装了多帧打包，可能有些电机是分多帧发送的，虽然目前还没用的高，不知道以后会不会买这种</li>
<li>好处：fdCAN 永远是纯通信层，电机逻辑变化不会污染 CAN 驱动。</li>
<li>==具体实现==
<ol>
<li>
<p>fdCAN提供发送接口给电机类，提供 sendFrame(const CanFrame&amp;) 接口，电机类不会直接调用 HAL。</p>
</li>
<li>
<p>在fdCANbus中注册电机,使用Motor_Base指针，这样所有继承Motor_Base的子类都可以注册</p>
</li>
<li>
<p>fdCAN搬运ISR中的数据包丢到队列，让电机类解析。</p>
</li>
<li>
<p>实现CAN发送频率为1kHz，与回传频率一致。这通过内部一个1kHz的调度器任务完成，该任务统一调度所有注册到总线上的对象。
<strong>调度流程的最终实现</strong>：</p>
<ol>
<li><strong>双注册</strong>: 用户需要将<strong>电机对象本身</strong>（如 <code>m3508_1</code>）和<strong>电机组对象</strong>（如 <code>DJI_Group_1</code>）都注册到 <code>fdCANbus</code>。
<ul>
<li>注册电机本身是为了让调度器能调用其 <code>update()</code> 方法，并让接收任务能通过 <code>matchesFrame()</code> 找到它并调用 <code>updateFeedback()</code>。</li>
<li>注册电机组是为了让调度器能调用其 <code>packCommand()</code> 方法来打包发送指令。</li>
</ul>
</li>
<li><strong>1kHz定时器中断</strong> 触发，释放 <code>schedulerTask_</code> 的信号量。</li>
<li><code>schedulerTask_</code> 被唤醒，开始执行两轮遍历：
<ul>
<li><strong>第一轮遍历 (Update)</strong>: 遍历 <code>motorList_</code>，对每个注册的对象调用 <code>update()</code> 方法。此时，<code>m3508_1-&gt;update()</code> 会被调用，执行PID计算并更新其内部的 <code>target_current_</code>。而 <code>DJI_Group_1-&gt;update()</code> 是空函数，不执行任何操作。</li>
<li><strong>第二轮遍历 (Pack &amp; Send)</strong>: 再次遍历 <code>motorList_</code>，对每个对象调用 <code>packCommand()</code>。此时，<code>m3508_1-&gt;packCommand()</code> 是空函数。而 <code>DJI_Group_1-&gt;packCommand()</code> 会被调用，它会访问其成员 <code>m3508_1</code> 的 <code>target_current_</code> 值，并将其打包成CAN帧。</li>
</ul>
</li>
<li><code>schedulerTask_</code> 将所有收集到的帧通过 <code>sendFrame()</code> 发送出去。
这种设计精确地分离了职责：电机对象负责计算，电机组对象负责打包。</li>
</ol>
</li>
<li>
<p>成员变量：FDCAN_HandleTypeDef* hfdcan、bus_id、静态数组管理电机指针</p>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
<li>
<p>FreeRTOS驱动设计</p>
<ol>
<li>封成相应的父类，这部分我暂时没想的太多</li>
<li>任务系统类，提供统一接口来创建和管理任务，绕过CubeMX的配置生成。
<ol>
<li>类似ROS节点中的<code>spin()</code>,继承任务系统的子类只需要负责<code>run</code>或者<code>loop</code></li>
<li>主要目的是把RTOS的任务抽象为一个功能单元</li>
</ol>
</li>
<li>通信抽象类，不一定是要用RTOS实现，一些可以用统一的函数实现参数共享。但大体还有有点类似ROS中的pub/sub或者service；
<ol>
<li>Publisher/Subscriber：一个任务/类可以向某个话题（队列）发布消息，另一个类订阅后在任务中处理。</li>
<li>Service/Client：用于“请求/响应”模式，比如参数配置、一次性命令。</li>
</ol>
</li>
<li>好处：以后不只是 CAN，还可以接 UART、SPI、传感器等，都能挂在这个 RTOS 通信框架里。</li>
<li>具体实现
<ol>
<li>任务调度（任务类），封装 FreeRTOS TaskHandle_t，统一管理任务创建、启动和运行逻辑。</li>
<li>通信机制（消息/话题类）抽象一个类似 ROS topic/service 的父类，后续不一定是完全使用FreeRTOS的queue之类的完成通信。
<ol>
<li>模仿 ROS 的 pub/sub：
<ol>
<li>publish(msg)</li>
<li>subscribe(callback)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>电机封装的实现</p>
<ol>
<li>
<p>首先有一个Motor_Base抽象类，作为父类，统一电机所需要的通用接口被后续的子类电机重写。</p>
</li>
<li>
<p><strong>核心设计：接收即转换与尺度统一</strong></p>
<ul>
<li><strong>接收即转换</strong>: 在 <code>DJI_Motor::updateFeedback()</code> 方法中，从CAN总线收到的原始电机转子数据（编码器值、转速）会<strong>立即</strong>通过调用 <code>virtual float get_GearRatio() const</code> 函数获得正确的减速比，并被转换为<strong>输出轴尺度</strong>的数据。</li>
<li><strong>状态统一</strong>: 转换后，所有存储在 <code>Motor_Base</code> 中的成员变量（<code>rpm_</code>, <code>angle_</code>, <code>totalAngle_</code>）都统一为<strong>输出轴的状态</strong>。</li>
<li><strong>控制闭环统一</strong>: 所有PID控制环路（在 <code>update()</code> 方法中）的目标值（<code>target_rpm_</code>）和反馈值（<code>this-&gt;rpm_</code>）都基于输出轴尺度进行计算，确保了控制的正确性。</li>
</ul>
</li>
<li>
<p>在之后</p>
<ol>
<li>DJI
<ol>
<li>有DJI_Motor管理单一电机和DJI_Group合帧。</li>
<li>DJI一条CAN上八个电机分上下片帧，id1~4一片，一个canid,5~8一片，一个canid</li>
<li>之后具体电机需要继承</li>
</ol>
</li>
<li>其他电机
<ol>
<li>继承Motor_Base完成各自的协议。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>电机发送报文的生成和回收报文的解析在电机类中实现</p>
</li>
<li>
<p>具体实现</p>
<ol>
<li>PID作为电机类中的成员，而非电机类继承PID类。</li>
<li>提供通用接口(Motor_Base抽象层)：</li>
</ol>
<p>setTargetRPM() / setTargetCurrent() / setTargetAngle()/setTargetTotalAngle()</p>
<p>getRPM() / getPosition() / getCurrent() / getTotalAngle()</p>
<p>packCommand()（把目标量转成 CAN 报文）</p>
<p>updateFeedback()（解析电机返回报文）
在之后由具体电机类完成闭环控制的封装。
3. 在电机类中把update()[更新电机所要发送参数] ,和packCommand()[打包参数发送]分开</p>
<ol>
<li>具体在fdCANbus中的操作</li>
<li>1kHz定时器中断触发 -&gt; fdcan_global_scheduler_tick_isr() 释放信号量 schedSem_。</li>
<li>schedulerTaskbody 从信号量等待中被唤醒。</li>
<li>schedulerTaskbody 遍历 motorList_，对每个注册的电机调用 m-&gt;update()。</li>
<li>在 update() 内部，电机根据自身状态（如 ANGLE_CONTROL）执行PID计算，并更新其内部的 target_current_。</li>
<li>schedulerTaskbody 再次遍历 motorList_，调用 m-&gt;packCommand()。</li>
<li>packCommand()（在 DJI_Group 中实现）读取刚刚由 update() 计算出的 target_current_，并将其打包成CAN帧。</li>
<li>schedulerTaskbody 将所有打包好的帧通过   sendFrame() 发送出去。</li>
<li>DJI_Motor 基类</li>
</ol>
<p>所有 DJI 电机共用的打包协议（4 电机合帧）。</p>
<p>具体型号（M3508、M2006、GM6020）继承这个类，负责具体反馈解析。</p>
<ol>
<li>DJI_Motor继承Motor_Base
<ol>
<li>负责保存电机单体的id,解析回传报文<code>updateFeedback()</code>，提供接口，不负责Group打包</li>
<li>M3508/M2006和M6020不在一条CAN上(会浪费bus位置)</li>
<li>DJI_Motor与DJI_Group
<ol>
<li>DJI_Motor是负责单电机,专注于反馈解析和状态存储</li>
<li>DJI_Group负责组帧</li>
<li>DJI_Motor被DJI_Group持有和检索。</li>
</ol>
</li>
</ol>
</li>
<li>其继承类 M3508/M2006
<ol>
<li>这俩发送接收协议一样，只是最大电流不同。</li>
</ol>
</li>
<li>GM6020
<ol>
<li>只有帧头和上面那个不同</li>
<li>接收</li>
</ol>
</li>
<li>线程安全
<ol>
<li><code>rxTask</code> (接收任务) 和 <code>schedulerTask</code> (调度任务) 之间存在数据共享（如 <code>rpm_</code>, <code>angle_</code>）。<code>rxTask</code> 是写入者，<code>schedulerTask</code> 是读取者。由于 <code>schedulerTask</code> 的优先级更高，并且在当前设计中，数据读取不是原子操作，理论上存在数据竞争的风险（尽管在1kHz的调度频率下实际发生的概率较低）。</li>
<li><strong>当前策略</strong>：暂时未加入显式的锁。依赖于FreeRTOS的任务调度和数据类型的原子性（float/int32在32位机上通常是原子读写的）来规避问题。如果未来出现数据不一致的问题，可以考虑在 <code>updateFeedback</code> 和 <code>update</code> 中对共享数据块使用 <code>taskENTER_CRITICAL()</code> / <code>taskEXIT_CRITICAL()</code> 进行保护。</li>
</ol>
</li>
<li>matchesFrame 的默认实现与扩展
<ol>
<li>此意义在于实现默认行为（比较 id_ 与 isExtended_），并允许子类 override（比如 DJI group 要匹配 group-feedback frame 并分发到成员）。</li>
<li>其实也可以把matchFrame删了，然后直接调用fdCANbus的matchesFrameDefualt。其实也是实现等价逻辑</li>
</ol>
</li>
<li>做好注册唯一性检查(IMPORTANT!)</li>
<li>电机生命周期应该是和单片机运行周期等价，感觉没有做析构的必要。</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>运行时序图</p>
<pre><code class="language-mermaid"><div class="mermaid">flowchart TD
    subgraph SCHED["fdCANbus Scheduler (per CAN, 1kHz)"]
      Tick["定时触发 1ms"]
      ForLoop["遍历 motorList[]"]
      Pack["调用 motor.packCommand()"]
      Batch["DJI: group 合并 -> 1 帧\nOthers: 单帧"]
      send["fdCAN.sendFrame(frame) -> HAL 发送"]
      Tick --> ForLoop --> Pack --> Batch --> send
    end

    subgraph BUS["CAN 总线 & 硬件"]
      CANBUS["物理 CAN 总线"]
      HAL["HAL/FDCAN 硬件层"]
    end

    subgraph RX["接收路径"]
      ISR["FDCAN Rx ISR\n(尽量短)"]
      ISR_Queue["RX 原始帧队列 (rtos topic/queue)"]
      RX_Task["fdCAN RX Task\n从队列 pop -> publish"]
      Dispatch["按 ID/规则分发给订阅 motor\n调用 motor.updateFeedback()"]
      ISR --> ISR_Queue --> RX_Task --> Dispatch
    end

    %% 连接 send -> bus -> isr
    send --> HAL --> CANBUS --> ISR

    %% motor update interaction
    Dispatch --> MotorUpdate["Motor 更新状态\n(角度/速度/电流)"]

    %% note: motor may update targets via other control tasks

</div></code></pre>
<pre class="hljs"><code><div>                        ┌─────────────────────────┐
                        │        FDCAN HW         │
                        │   (FIFO0, TX FIFO)      │
                        └───────────┬─────────────┘
                                    │ RX FIFO 中断
                                    ▼
                        ┌─────────────────────────┐
                        │ fdcan_global_rx_isr()   │
                        │ (全局C回调，找到bus)   │
                        └───────────┬─────────────┘
                                    │ pushRxFromISR()
                                    ▼
                        ┌─────────────────────────┐
                        │     fdCANbus::rxQueue_  │
                        │   (RtosQueue&lt;CanFrame&gt;) │
                        └───────────┬─────────────┘
                                    │
                       RxTask wakes│ recv() from queue
                                    ▼
                        ┌─────────────────────────┐
                        │   fdCANbus::rxTaskbody  │
                        │   遍历 motorList_       │
                        │   motor-&gt;matchesFrame() │
                        │   motor-&gt;updateFeedback │
                        └───────────┬─────────────┘
                                    │
                         ┌──────────┴──────────┐
                         │                     │
               ┌─────────────────┐   ┌─────────────────┐
               │   Motor_Base    │   │  Motor_Subclass │
               │ (base class)    │   │ (DJI_M3508 etc.)│
               │ updateFeedback()│   │ override packs  │
               │  getRPM()/...   │   │ specific logic │
               └─────────────────┘   └─────────────────┘
                                    ▲
                                    │ packCommand()
                                    │
                        ┌───────────┴────────────┐
                        │ fdCANbus::schedulerTask│
                        │ (<span class="hljs-number">1kHz</span> 调度)            │
                        │ 遍历 motorList_        │
                        │ 收集各 motor packCommand│
                        │ sendFrame()             │
                        └───────────┬────────────┘
                                    │
                        ┌───────────┴────────────┐
                        │   FDCAN TX FIFO         │
                        │   HAL_FDCAN_AddMessage  │
                        └─────────────────────────┘


</div></code></pre>
<h4 id="user%E5%B1%82">User层</h4>
<pre><code>用于存放基于RC10_LIB所写的应用层，如机构控制类，Debug类，demo类。
以及实际所需要创建的任务或启动项。
</code></pre>
<h3 id="%E5%90%8E%E7%BB%AD%E5%BC%80%E5%8F%91%E5%8D%8F%E4%BD%9C%E8%A7%84%E5%AE%9A">后续开发协作规定</h3>
<ol>
<li>代码中尽量写入多的注释，如果自己懒得写可以使用vscode自带的ai进行补全，笔者的注释也基本是用ai写的。</li>
<li></li>
</ol>

</body>
</html>
